---
description: タスク生成後に spec.md、plan.md、tasks.md 間の非破壊的なクロスアーティファクト整合性と品質分析を実行します。
---

## ユーザー入力

```text
$ARGUMENTS
```

続行する前に、ユーザー入力を**必ず**考慮してください（空でない場合）。

## 目標

実装前に、3つのコアアーティファクト（`spec.md`、`plan.md`、`tasks.md`）間の不一致、重複、曖昧性、不十分な項目を特定します。このコマンドは、`/speckit.tasks` が完全な `tasks.md` を正常に生成した後にのみ実行する必要があります。

## 操作制約

**厳密に読み取り専用**: ファイルを変更**しない**でください。構造化された分析レポートを出力します。オプションの修正計画を提供します（ユーザーは手動で呼び出されるフォローアップ編集コマンドの前に明示的に承認する必要があります）。

**憲法の権限**: プロジェクト憲法（`.specify/memory/constitution.md`）はこの分析範囲内で**交渉不可能**です。憲法の競合は自動的に重要であり、原則の希釈、再解釈、または黙認ではなく、仕様、計画、またはタスクの調整が必要です。原則自体を変更する必要がある場合、それは `/speckit.analyze` の外部で、別の明示的な憲法更新で発生する必要があります。

## 実行ステップ

### 1. 分析コンテキストの初期化

リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks` を一度実行し、FEATURE_DIR と AVAILABLE_DOCS の JSON を解析します。絶対パスを導出:

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

必要なファイルが欠落している場合、エラーメッセージで中止します（欠落している前提条件コマンドを実行するようユーザーに指示）。
"I'm Groot" のような引数の一重引用符には、エスケープ構文を使用: 例 'I'\''m Groot'（または可能であれば二重引用符: "I'm Groot"）。

### 2. アーティファクトを読み込む（プログレッシブディスクロージャー）

各アーティファクトから最小限の必要なコンテキストのみを読み込みます:

**spec.md から:**

- 概要/コンテキスト
- 機能要件
- 非機能要件
- ユーザーストーリー
- エッジケース（存在する場合）

**plan.md から:**

- アーキテクチャ/スタック選択
- データモデル参照
- フェーズ
- 技術的制約

**tasks.md から:**

- タスク ID
- 説明
- フェーズグルーピング
- 並列マーカー [P]
- 参照されたファイルパス

**憲法から:**

- 原則検証のために `.specify/memory/constitution.md` を読み込む

### 3. セマンティックモデルの構築

内部表現を作成します（出力に生のアーティファクトを含めないでください）:

- **要件インベントリ**: 安定したキーを持つ各機能 + 非機能要件（命令的なフレーズに基づいてスラグを導出; 例: "ユーザーがファイルをアップロードできる" → `user-can-upload-file`）
- **ユーザーストーリー/アクションインベントリ**: 受け入れ基準を持つ個別のユーザーアクション
- **タスクカバレッジマッピング**: 各タスクを1つ以上の要件またはストーリーにマップ（キーワード/明示的な参照パターン（ID またはキーフレーズなど）による推論）
- **憲法ルールセット**: 原則名と MUST/SHOULD 規範的ステートメントを抽出

### 4. 検出パス（トークン効率的な分析）

高シグナルの発見に焦点を当てます。合計50の発見に制限; 残りをオーバーフロー要約に集約します。

#### A. 重複検出

- ほぼ重複する要件を特定
- 統合のために低品質の表現をマーク

#### B. 曖昧性検出

- 測定可能な基準が欠けている曖昧な形容詞（高速、スケーラブル、安全、直感的、堅牢）にフラグを立てる
- 未解決のプレースホルダー（TODO、TKTK、???、`<placeholder>` など）にフラグを立てる

#### C. 不十分な仕様

- 動詞を持つが、オブジェクトまたは測定可能な成果が欠けている要件
- 受け入れ基準の整合性が欠けているユーザーストーリー
- 仕様/計画で定義されていないファイルまたはコンポーネントを参照するタスク

#### D. 憲法の整合性

- MUST 原則と競合する要件または計画要素
- 憲法から欠落している必須セクションまたは品質ゲート

#### E. カバレッジギャップ

- 関連するタスクがゼロの要件
- マップされた要件/ストーリーがないタスク
- タスクに反映されていない非機能要件（例: パフォーマンス、セキュリティ）

#### F. 不一致

- 用語のドリフト（ファイル間で異なる名前が付けられた同じ概念）
- 計画で参照されているが仕様に存在しないデータエンティティ（またはその逆）
- タスクの順序付けの矛盾（例: 依存関係ノートなしの基盤セットアップタスクの前の統合タスク）
- 競合する要件（例: 1つは Next.js を要求し、他は Vue を指定）

### 5. 重要度の割り当て

この発見を優先順位付けするヒューリスティックを使用:

- **重要**: MUST 憲法違反、コア仕様アーティファクトの欠落、またはベースライン機能をブロックするカバレッジがゼロの要件
- **高**: 重複または競合する要件、曖昧なセキュリティ/パフォーマンス属性、テスト不可能な受け入れ基準
- **中**: 用語のドリフト、非機能タスクカバレッジの欠落、不十分に指定されたエッジケース
- **低**: スタイル/表現の改善、実行順序に影響しない軽微な冗長性

### 6. コンパクト分析レポートの作成

マークダウンレポートを出力します（ファイル書き込みなし）、次の構造で:

## 仕様分析レポート

| ID | カテゴリ | 重要度 | 場所 | 要約 | 推奨事項 |
|----|----------|----------|-------------|---------|----------------|
| A1 | 重複 | 高 | spec.md:L120-134 | 2つの類似した要件 ... | 表現をマージ; より明確なバージョンを保持 |

（発見ごとに1行を追加; カテゴリの頭文字で接頭辞が付けられた安定した ID を生成）

**カバレッジサマリーテーブル:**

| 要件キー | タスクあり？ | タスク ID | 注記 |
|-----------------|-----------|----------|-------|

**憲法整合性の問題:**（ある場合）

**マップされていないタスク:**（ある場合）

**メトリクス:**

- 合計要件数
- 合計タスク数
- カバレッジ %（>=1 タスクを持つ要件）
- 曖昧性カウント
- 重複カウント
- 重要な問題カウント

### 7. 次のアクションを提供

レポートの最後に、簡潔な次のアクションブロックを出力:

- 重要な問題が存在する場合: `/speckit.implement` の前に解決を推奨
- 低/中のみの場合: ユーザーは続行できますが、改善提案を提供
- 明示的なコマンド提案を提供: 例: "改良で /speckit.specify を実行"、"アーキテクチャを調整するために /speckit.plan を実行"、"'performance-metrics' のカバレッジを追加するために tasks.md を手動で編集"

### 8. 修正を提供

ユーザーに尋ねる: "上位 N の問題について具体的な修正編集を提案しますか？"（自動的に適用しないでください）

## 操作原則

### コンテキスト効率

- **最小限の高シグナルトークン**: 実行可能な発見に焦点を当て、網羅的なドキュメントではない
- **プログレッシブディスクロージャー**: アーティファクトを段階的に読み込む; すべての内容を分析にダンプしない
- **トークン効率的な出力**: 発見テーブルを50行に制限; オーバーフローを要約
- **決定論的な結果**: 変更なしに再実行すると、一貫した ID とカウントが生成される必要があります

### 分析ガイドライン

- **ファイルを変更しない**（これは読み取り専用の分析です）
- **欠落しているセクションを幻覚しない**（存在しない場合、正確に報告）
- **憲法違反を優先**（これらは常に重要です）
- **網羅的なルールよりも例を使用**（汎用パターンではなく、具体的なインスタンスを引用）
- **ゼロの問題を優雅に報告**（カバレッジ統計を含む成功レポートを発行）

## コンテキスト

$ARGUMENTS
