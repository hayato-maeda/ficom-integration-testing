---
description: ユーザー要件に基づいて現在の機能のカスタムチェックリストを生成します。
---

## チェックリストの目的: 「英語のためのユニットテスト」

**重要なコンセプト**: チェックリストは**要件記述のためのユニットテスト**です - 特定のドメインにおける要件の品質、明確性、完全性を検証します。

**検証/テスト用ではない**:

- ❌ 「ボタンが正しくクリックされることを確認」ではない
- ❌ 「エラー処理が機能することをテスト」ではない
- ❌ 「API が 200 を返すことを確認」ではない
- ❌ コード/実装が仕様に一致するかをチェックするものではない

**要件品質検証用**:

- ✅ 「すべてのカードタイプに対して視覚階層要件が定義されているか？」（完全性）
- ✅ 「'目立つ表示' は具体的なサイジング/配置で定量化されているか？」（明確性）
- ✅ 「ホバー状態要件はすべてのインタラクティブ要素で一貫しているか？」（一貫性）
- ✅ 「キーボードナビゲーションのアクセシビリティ要件が定義されているか？」（カバレッジ）
- ✅ 「ロゴ画像の読み込み失敗時の仕様は定義されているか？」（エッジケース）

**比喩**: 仕様が英語で書かれたコードなら、チェックリストはそのユニットテストスイートです。実装が機能するかではなく、要件が適切に書かれ、完全で、曖昧でなく、実装準備ができているかをテストします。

## ユーザー入力

```text
$ARGUMENTS
```

続行する前に、ユーザー入力を**必ず**考慮してください（空でない場合）。

## 実行ステップ

1. **セットアップ**: リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json` を実行し、FEATURE_DIR と AVAILABLE_DOCS リストの JSON を解析します。
   - すべてのファイルパスは絶対パスである必要があります。
   - "I'm Groot" のような引数の一重引用符には、エスケープ構文を使用: 例 'I'\''m Groot'（または可能であれば二重引用符: "I'm Groot"）

2. **意図の明確化（動的）**: ユーザーの表現 + spec/plan/tasks から抽出されたシグナルから、最大3つの初期コンテキスト明確化質問を導出します。これらは以下である必要があります:
   - チェックリスト内容を実質的に変更する情報についてのみ尋ねる
   - `$ARGUMENTS` で既に明確な場合は個別にスキップ
   - 広さよりも精度を優先

   生成アルゴリズム:
   1. シグナルを抽出: 機能ドメインキーワード（例: auth、latency、UX、API）、リスク指標（"critical"、"must"、"compliance"）、ステークホルダーヒント（"QA"、"review"、"security team"）、明示的な成果物（"a11y"、"rollback"、"contracts"）
   2. シグナルを関連性でランク付けされた候補フォーカス領域（最大4つ）にクラスター化
   3. 明示的でない場合、想定される対象者とタイミング（作成者、レビュアー、QA、リリース）を特定
   4. 欠けている次元を検出: スコープの幅、深さ/厳格さ、リスク重視、除外境界、測定可能な受け入れ基準
   5. これらのアーキタイプから選択された質問を定式化:
      - スコープの絞り込み（例: "これは X と Y との統合タッチポイントを含むべきか、ローカルモジュールの正確性に限定すべきか？"）
      - リスク優先順位付け（例: "これらの潜在的なリスク領域のうち、どれが必須のゲートチェックを受けるべきか？"）
      - 深さの調整（例: "これは軽量なプレコミットサニティリストか、正式なリリースゲートか？"）
      - 対象者のフレーミング（例: "これは作成者のみが使用するのか、PR レビュー中のピアが使用するのか？"）
      - 境界の除外（例: "今回、パフォーマンスチューニング項目を明示的に除外すべきか？"）
      - シナリオクラスのギャップ（例: "回復フローが検出されていません—ロールバック/部分失敗パスはスコープ内ですか？"）

   質問フォーマットルール:
   - オプションを提示する場合、列を持つコンパクトなテーブルを生成: オプション | 候補 | 重要な理由
   - A〜E オプションに制限、最大; 自由形式の回答がより明確な場合はテーブルを省略
   - ユーザーが既に述べたことを再度述べるよう求めない
   - 推測的なカテゴリを避ける（幻覚なし）。不確かな場合、明示的に尋ねる: "X がスコープに属するかを確認してください。"

   インタラクション不可能な場合のデフォルト:
   - 深さ: 標準
   - 対象者: コード関連の場合はレビュアー（PR）; それ以外は作成者
   - フォーカス: 上位2つの関連性クラスター

   質問を出力（Q1/Q2/Q3 とラベル付け）。回答後: ≥2のシナリオクラス（代替/例外/回復/非機能ドメイン）が不明確なまま残っている場合、最大2つの追加のターゲット化されたフォローアップ（Q4/Q5）を1行の正当化と共に尋ねることができます（例: "未解決の回復パスリスク"）。5つの合計質問を超えないでください。ユーザーが明示的に辞退した場合、エスカレーションをスキップします。

3. **ユーザーリクエストを理解**: `$ARGUMENTS` + 明確化回答を組み合わせ:
   - チェックリストのテーマを導出（例: セキュリティ、レビュー、デプロイ、ux）
   - ユーザーが言及した明示的な必須項目を統合
   - フォーカス選択をカテゴリスキャフォールディングにマップ
   - spec/plan/tasks から欠けているコンテキストを推論（幻覚しないでください）

4. **機能コンテキストを読み込む**: FEATURE_DIR から読み込み:
   - spec.md: 機能要件とスコープ
   - plan.md（存在する場合）: 技術詳細、依存関係
   - tasks.md（存在する場合）: 実装タスク

   **コンテキスト読み込み戦略**:
   - アクティブなフォーカス領域に関連する必要な部分のみを読み込む（ファイル全体をダンプしない）
   - 長いセクションを簡潔なシナリオ/要件の箇条書きに要約することを優先
   - プログレッシブディスクロージャーを使用: ギャップが検出された場合にのみフォローオン取得を追加
   - ソースドキュメントが大きい場合、生のテキストを埋め込む代わりに中間サマリー項目を生成

5. **チェックリストを生成** - 「要件のユニットテスト」を作成:
   - `FEATURE_DIR/checklists/` ディレクトリが存在しない場合は作成
   - 一意のチェックリストファイル名を生成:
     - ドメインに基づく短い説明的な名前を使用（例: `ux.md`、`api.md`、`security.md`）
     - フォーマット: `[domain].md`
     - ファイルが存在する場合、既存のファイルに追加
   - CHK001 から始まる項目に順番に番号を付ける
   - 各 `/speckit.checklist` 実行は新しいファイルを作成します（既存のチェックリストを上書きしません）

   **コア原則 - 実装ではなく要件をテスト**:
   すべてのチェックリスト項目は、以下について要件自体を評価する必要があります:
   - **完全性**: すべての必要な要件が存在するか？
   - **明確性**: 要件は曖昧でなく具体的か？
   - **一貫性**: 要件は互いに整合しているか？
   - **測定可能性**: 要件は客観的に検証可能か？
   - **カバレッジ**: すべてのシナリオ/エッジケースが対処されているか？

   **カテゴリ構造** - 要件品質の次元でアイテムをグループ化:
   - **要件の完全性**（すべての必要な要件が文書化されているか？）
   - **要件の明確性**（要件は具体的で曖昧でないか？）
   - **要件の一貫性**（要件は競合なく整合しているか？）
   - **受け入れ基準の品質**（成功基準は測定可能か？）
   - **シナリオカバレッジ**（すべてのフロー/ケースが対処されているか？）
   - **エッジケースカバレッジ**（境界条件が定義されているか？）
   - **非機能要件**（パフォーマンス、セキュリティ、アクセシビリティなどが指定されているか？）
   - **依存関係と前提**（文書化され検証されているか？）
   - **曖昧性と競合**（何を明確化する必要があるか？）

   **チェックリスト項目の書き方 - 「英語のユニットテスト」**:

   ❌ **間違い**（実装のテスト）:
   - "ランディングページが3つのエピソードカードを表示することを確認"
   - "デスクトップでホバー状態が機能することをテスト"
   - "ロゴクリックがホームにナビゲートすることを確認"

   ✅ **正しい**（要件品質のテスト）:
   - "特集エピソードの正確な数とレイアウトが指定されているか？[完全性]"
   - "'目立つ表示' は具体的なサイジング/配置で定量化されているか？[明確性]"
   - "ホバー状態要件はすべてのインタラクティブ要素で一貫しているか？[一貫性]"
   - "すべてのインタラクティブ UI にキーボードナビゲーション要件が定義されているか？[カバレッジ]"
   - "ロゴ画像の読み込み失敗時のフォールバック動作が指定されているか？[エッジケース]"
   - "非同期エピソードデータのローディング状態が定義されているか？[完全性]"
   - "競合する UI 要素の視覚階層が仕様で定義されているか？[明確性]"

   **項目構造**:
   各項目は次のパターンに従う必要があります:
   - 要件品質について尋ねる質問形式
   - 仕様/計画に書かれている（または書かれていない）ことに焦点を当てる
   - [完全性/明確性/一貫性/など]で品質次元を含める
   - 既存の要件をチェックする場合は仕様セクション `[Spec §X.Y]` を参照
   - 欠けている要件をチェックする場合は `[Gap]` マーカーを使用

   **品質次元別の例**:

   完全性:
   - "すべての API 失敗モードに対してエラー処理要件が定義されているか？[Gap]"
   - "すべてのインタラクティブ要素にアクセシビリティ要件が指定されているか？[完全性]"
   - "レスポンシブレイアウトのモバイルブレークポイント要件が定義されているか？[Gap]"

   明確性:
   - "'高速ローディング' は具体的なタイミング閾値で定量化されているか？[明確性、Spec §NFR-2]"
   - "'関連エピソード' の選択基準は明示的に定義されているか？[明確性、Spec §FR-5]"
   - "'目立つ' は測定可能な視覚的プロパティで定義されているか？[曖昧性、Spec §FR-4]"

   一貫性:
   - "ナビゲーション要件はすべてのページで整合しているか？[一貫性、Spec §FR-10]"
   - "カードコンポーネント要件はランディングと詳細ページ間で一貫しているか？[一貫性]"

   カバレッジ:
   - "ゼロ状態シナリオ（エピソードなし）の要件が定義されているか？[カバレッジ、エッジケース]"
   - "同時ユーザーインタラクションシナリオが対処されているか？[カバレッジ、Gap]"
   - "部分的なデータローディング失敗の要件が指定されているか？[カバレッジ、例外フロー]"

   測定可能性:
   - "視覚階層要件は測定可能/テスト可能か？[受け入れ基準、Spec §FR-1]"
   - "'バランスの取れた視覚的重み' は客観的に検証可能か？[測定可能性、Spec §FR-2]"

   **トレーサビリティ要件**:
   - 最小: ≥80%の項目に少なくとも1つのトレーサビリティ参照が必要
   - 各項目は以下を参照する必要があります: 仕様セクション `[Spec §X.Y]`、またはマーカーを使用: `[Gap]`、`[曖昧性]`、`[競合]`、`[前提]`
   - ID システムが存在しない場合: "要件と受け入れ基準の ID スキームが確立されているか？[トレーサビリティ]"

   **問題の表面化と解決**（要件品質の問題）:
   要件自体について質問します:
   - 曖昧性: "用語 '高速' は具体的なメトリクスで定量化されているか？[曖昧性、Spec §NFR-1]"
   - 競合: "ナビゲーション要件は §FR-10 と §FR-10a 間で競合しているか？[競合]"
   - 前提: "'常に利用可能なポッドキャスト API' の前提は検証されているか？[前提]"
   - 依存関係: "外部ポッドキャスト API 要件が文書化されているか？[依存関係、Gap]"
   - 欠けている定義: "'視覚階層' は測定可能な基準で定義されているか？[Gap]"

   **🚫 絶対に禁止** - これらは実装テストになり、要件テストではありません:
   - ❌ "確認"、"テスト"、"確認"、"チェック" + 実装動作で始まる項目
   - ❌ コード実行、ユーザーアクション、システム動作への参照
   - ❌ "正しく表示"、"適切に機能"、"期待通りに機能"
   - ❌ "クリック"、"ナビゲート"、"レンダリング"、"ロード"、"実行"
   - ❌ テストケース、テスト計画、QA 手順
   - ❌ 実装詳細（フレームワーク、API、アルゴリズム）

   **✅ 必須パターン** - これらは要件品質をテストします:
   - ✅ "[要件タイプ]は[シナリオ]に対して定義/指定/文書化されているか？"
   - ✅ "[曖昧な用語]は具体的な基準で定量化/明確化されているか？"
   - ✅ "要件は[セクション A]と[セクション B]間で一貫しているか？"
   - ✅ "[要件]は客観的に測定/検証可能か？"
   - ✅ "[エッジケース/シナリオ]は要件で対処されているか？"
   - ✅ "仕様は[欠けている側面]を定義しているか？"

6. **構造リファレンス**: タイトル、メタセクション、カテゴリ見出し、ID フォーマットについて `.specify/templates/checklist-template.md` の正規テンプレートに従ってチェックリストを生成します。テンプレートが利用できない場合は使用: H1 タイトル、目的/作成メタ行、CHK001 から開始してグローバルに増分する ID を持つ `- [ ] CHK### <要件項目>` 行を含む `##` カテゴリセクション。

7. **報告**: 作成されたチェックリストへの完全なパス、項目数を出力し、各実行が新しいファイルを作成することをユーザーに思い出させます。要約:
   - 選択されたフォーカス領域
   - 深さレベル
   - アクター/タイミング
   - 組み込まれた明示的なユーザー指定の必須項目

**重要**: 各 `/speckit.checklist` コマンド呼び出しは、ファイルが既に存在しない限り、短い説明的な名前を使用してチェックリストファイルを作成します。これにより:

- 異なるタイプの複数のチェックリスト（例: `ux.md`、`test.md`、`security.md`）
- チェックリストの目的を示すシンプルで覚えやすいファイル名
- `checklists/` フォルダでの簡単な識別とナビゲーション

乱雑さを避けるため、説明的なタイプを使用し、完了したら古いチェックリストをクリーンアップしてください。
