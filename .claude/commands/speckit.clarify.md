---
description: 現在の機能仕様で不十分な領域を特定し、最大5つの高度にターゲット化された明確化質問をして、回答を仕様に反映します。
---

## ユーザー入力

```text
$ARGUMENTS
```

続行する前に、ユーザー入力を**必ず**考慮してください（空でない場合）。

## 概要

目標: アクティブな機能仕様の曖昧性や未決定のポイントを検出して削減し、明確化を仕様ファイルに直接記録します。

注意: この明確化ワークフローは `/speckit.plan` を呼び出す前に実行（および完了）されることが期待されます。ユーザーが明示的に明確化をスキップすると述べた場合（例: 探索的スパイク）、続行できますが、下流の再作業リスクが増加することを警告する必要があります。

実行ステップ:

1. リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json --paths-only` を**一度**実行します（`--json --paths-only` モード / `-Json -PathsOnly` を組み合わせ）。最小限の JSON ペイロードフィールドを解析:
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （将来の連鎖フローのために `IMPL_PLAN`、`TASKS` をオプションでキャプチャ）
   - JSON 解析が失敗した場合、中止してユーザーに `/speckit.specify` を再実行するか、機能ブランチ環境を確認するよう指示
   - "I'm Groot" のような引数の一重引用符には、エスケープ構文を使用: 例 'I'\''m Groot'（または可能であれば二重引用符: "I'm Groot"）

2. 現在の仕様ファイルを読み込みます。この分類法を使用して構造化された曖昧性とカバレッジスキャンを実行します。各カテゴリについて、ステータスをマーク: 明確 / 部分的 / 欠落。優先順位付けに使用される内部カバレッジマップを作成します（質問がない場合を除き、生のマップを出力しないでください）。

   機能スコープと動作:
   - コアユーザー目標と成功基準
   - 明示的なスコープ外宣言
   - ユーザーロール/ペルソナの区別

   ドメインとデータモデル:
   - エンティティ、属性、関係
   - アイデンティティと一意性ルール
   - ライフサイクル/状態遷移
   - データ量/スケールの前提

   インタラクションと UX フロー:
   - 重要なユーザージャーニー/シーケンス
   - エラー/空/ローディング状態
   - アクセシビリティまたはローカリゼーションの注記

   非機能品質属性:
   - パフォーマンス（レイテンシ、スループット目標）
   - スケーラビリティ（水平/垂直、制限）
   - 信頼性と可用性（稼働時間、回復期待）
   - 可観測性（ログ、メトリクス、トレーシング信号）
   - セキュリティとプライバシー（認証/認可、データ保護、脅威前提）
   - コンプライアンス/規制制約（ある場合）

   統合と外部依存関係:
   - 外部サービス/API と障害モード
   - データインポート/エクスポート形式
   - プロトコル/バージョニング前提

   エッジケースと障害処理:
   - ネガティブシナリオ
   - レート制限/スロットリング
   - 競合解決（例: 同時編集）

   制約とトレードオフ:
   - 技術的制約（言語、ストレージ、ホスティング）
   - 明示的なトレードオフまたは却下された代替案

   用語と一貫性:
   - 正規の用語集用語
   - 回避された同義語/非推奨用語

   完了シグナル:
   - 受け入れ基準のテスト可能性
   - 測定可能な完了定義スタイルの指標

   その他/プレースホルダー:
   - TODO マーカー/未解決の決定
   - 定量化が欠けている曖昧な形容詞（"堅牢"、"直感的"）

   部分的または欠落ステータスの各カテゴリについて、以下の場合を除き、候補質問の機会を追加します:
   - 明確化が実装または検証戦略を実質的に変更しない
   - 情報は計画フェーズに延期する方が良い（内部的に注記）

3. 候補明確化質問の優先順位付けされたキューを（内部的に）生成します（最大5つ）。それらすべてを一度に出力しないでください。これらの制約を適用:
    - セッション全体で合計最大10の質問
    - 各質問は以下のいずれかで回答可能である必要があります:
       - 短い選択肢（2〜5の明確で相互排他的なオプション）、または
       - 1語/短いフレーズの回答（明示的に制約: "5語以内で回答"）
    - 回答が以下に実質的に影響を与える質問のみを含める: アーキテクチャ、データモデリング、タスク分解、テスト設計、UX 動作、運用準備、またはコンプライアンス検証
    - カテゴリカバレッジのバランスを確保: 最も影響の大きい未解決カテゴリを最初にカバーするよう試みる; 1つの高影響領域（例: セキュリティ態勢）が未解決の場合、2つの低影響質問を避ける
    - 既に回答された、些細なスタイル上の好み、または計画レベルの実行詳細（正確性をブロックしない限り）の質問を除外
    - 下流の再作業リスクを減らすか、ずれた受け入れテストを防ぐ明確化を優先
    - 5つ以上のカテゴリが未解決のままの場合、（影響 * 不確実性）ヒューリスティックで上位5つを選択

4. 順次質問ループ（インタラクティブ）:
    - 一度に正確に1つの質問を提示
    - 選択肢質問の場合:
       - **すべてのオプションを分析**し、以下に基づいて**最も適切なオプション**を決定:
          - プロジェクトタイプのベストプラクティス
          - 類似実装の一般的なパターン
          - リスク削減（セキュリティ、パフォーマンス、保守性）
          - 仕様に見える明示的なプロジェクト目標または制約との整合性
       - 明確な理由（このオプションが最良の選択である理由を説明する1〜2文）を含む**推奨オプション**を先頭に目立つように提示
       - フォーマット: `**推奨:** オプション [X] - <理由>`
       - 次に、すべてのオプションをマークダウンテーブルとしてレンダリング:

       | オプション | 説明 |
       |--------|-------------|
       | A | <オプション A の説明> |
       | B | <オプション B の説明> |
       | C | <オプション C の説明>（必要に応じて D/E を追加、最大5つ） |
       | 短い回答 | 別の短い回答を提供（≤5語）（自由形式の代替が適切な場合のみ含める） |

       - テーブルの後に追加: `オプション文字（例: "A"）で回答するか、"はい" または "推奨" と言って推奨を受け入れるか、独自の短い回答を提供できます。`
    - 短い回答スタイルの場合（意味のある離散オプションなし）:
       - ベストプラクティスとコンテキストに基づいて**提案された回答**を提供
       - フォーマット: `**提案:** <提案された回答> - <簡単な理由>`
       - 次に出力: `形式: 短い回答（≤5語）。"はい" または "提案" と言って提案を受け入れるか、独自の回答を提供できます。`
    - ユーザーが回答した後:
       - ユーザーが "はい"、"推奨"、または "提案" と回答した場合、以前に述べた推奨/提案を回答として使用
       - それ以外の場合、回答が1つのオプションにマップするか、≤5語の制約に適合するかを検証
       - 曖昧な場合、迅速な明確化を求める（カウントは同じ質問に属する; 進まない）
       - 満足したら、作業メモリに記録（まだディスクに書き込まない）し、次のキューに入れられた質問に移動
    - 以下の場合、さらなる質問を停止:
       - すべての重要な曖昧性が早期に解決（残りのキューに入れられた項目が不要になる）、または
       - ユーザーが完了を示す（"完了"、"良い"、"もうない"）、または
       - 5つの質問に達する
    - 将来のキューに入れられた質問を事前に明らかにしない
    - 開始時に有効な質問が存在しない場合、重要な曖昧性がないことをすぐに報告

5. 各受け入れられた回答後の統合（インクリメンタル更新アプローチ）:
    - 仕様のメモリ内表現（開始時に一度読み込まれる）と生のファイル内容を維持
    - このセッションで最初に統合された回答の場合:
       - `## 明確化` セクションが存在することを確認（仕様テンプレートに従って、最高レベルのコンテキスト/概要セクションの直後に作成、存在しない場合）
       - その下に、今日の `### セッション YYYY-MM-DD` サブヘッディングを作成（存在しない場合）
    - 受け入れ直後に箇条書き行を追加: `- Q: <質問> → A: <最終回答>`
    - 次に、最も適切なセクションに明確化をすぐに適用:
       - 機能の曖昧性 → 機能要件の箇条書きを更新または追加
       - ユーザーインタラクション/アクター区別 → ユーザーストーリーまたはアクターサブセクション（存在する場合）を明確化されたロール、制約、またはシナリオで更新
       - データ形状/エンティティ → データモデルを更新（フィールド、タイプ、関係を追加）順序を保持; 追加された制約を簡潔に注記
       - 非機能的制約 → 非機能/品質属性セクションで測定可能な基準を追加/変更（曖昧な形容詞をメトリクスまたは明示的な目標に変換）
       - エッジケース/ネガティブフロー → エッジケース/エラー処理の下に新しい箇条書きを追加（またはテンプレートがプレースホルダーを提供する場合、そのようなサブセクションを作成）
       - 用語の競合 → 仕様全体で用語を正規化; 必要な場合のみ元の用語を保持し、一度 `(以前は "X" と呼ばれていた)` を追加
    - 明確化が以前の曖昧なステートメントを無効にする場合、複製する代わりにそのステートメントを置き換える; 古い矛盾するテキストを残さない
    - コンテキスト損失のリスクを最小限に抑えるために、各統合後に仕様ファイルを保存（アトミック上書き）
    - フォーマットを保持: 無関係なセクションを並べ替えない; 見出し階層を intact に保つ
    - 挿入された各明確化を最小限でテスト可能に保つ（物語のドリフトを避ける）

6. 検証（各書き込み後および最終パスで実行）:
   - 明確化セッションには、受け入れられた回答ごとに正確に1つの箇条書きが含まれる（重複なし）
   - 合計質問数（受け入れられた）≤ 5
   - 更新されたセクションには、新しい回答が解決することを意図した曖昧なプレースホルダーが残っていない
   - 矛盾する以前のステートメントが残っていない（削除された無効な代替選択肢をスキャン）
   - マークダウン構造が有効; 許可された新しい見出しのみ: `## 明確化`、`### セッション YYYY-MM-DD`
   - 用語の一貫性: すべての更新されたセクションで使用される同じ正規の用語

7. 更新された仕様を `FEATURE_SPEC` に書き戻します。

8. 完了を報告（質問ループが終了または早期終了後）:
   - 質問された & 回答された数
   - 更新された仕様へのパス
   - 触れられたセクション（名前をリスト）
   - 各分類法カテゴリをステータスでリストするカバレッジサマリーテーブル: 解決済み（部分的/欠落であり、対処された）、延期（質問クォータを超えるか、計画により適している）、明確（既に十分）、未解決（まだ部分的/欠落だが影響が低い）
   - 未解決または延期が残っている場合、`/speckit.plan` に進むか、計画後に `/speckit.clarify` を再度実行することを推奨するかどうかを推奨
   - 提案された次のコマンド

動作ルール:

- 意味のある曖昧性が見つからない場合（またはすべての潜在的な質問が低影響である場合）、応答: "正式な明確化に値する重要な曖昧性は検出されませんでした。" そして、続行を提案
- 仕様ファイルが欠落している場合、ユーザーに最初に `/speckit.specify` を実行するよう指示（ここで新しい仕様を作成しない）
- 合計5つの質問を超えない（単一の質問の明確化再試行は新しい質問としてカウントされない）
- 技術スタックの質問は、欠如が機能の明確性をブロックしない限り、推測的に避ける
- ユーザーの早期終了シグナル（"停止"、"完了"、"続行"）を尊重
- 完全なカバレッジのために質問がない場合、コンパクトなカバレッジサマリー（すべてのカテゴリが明確）を出力し、次に進むことを提案
- クォータに達したが、未解決の高影響カテゴリが残っている場合、延期の下に理由と共に明示的にフラグを立てる

優先順位付けのコンテキスト: $ARGUMENTS
