---
description: 自然言語の機能説明から機能仕様書を作成または更新します。
---

## ユーザー入力

```text
$ARGUMENTS
```

続行する前に、ユーザー入力を**必ず**考慮してください（空でない場合）。

## 概要

トリガーメッセージで `/speckit.specify` の後にユーザーが入力したテキスト**が**機能説明です。`$ARGUMENTS` が以下に文字通り表示されていても、この会話で常に利用可能であると想定してください。ユーザーが空のコマンドを提供した場合を除き、再度尋ねないでください。

その機能説明を受けて、以下を実行します：

1. **簡潔な短い名前を生成**（2〜4語）してブランチ名とする:
   - 機能説明を分析し、最も意味のあるキーワードを抽出
   - 機能の本質を捉える2〜4語の短い名前を作成
   - 可能な限りアクション-名詞形式を使用（例: "add-user-auth", "fix-payment-bug"）
   - 技術用語や略語を保持（OAuth2, API, JWT など）
   - 簡潔に保ちながら、一目で機能を理解できる程度に説明的に
   - 例:
     - "ユーザー認証を追加したい" → "user-auth"
     - "API の OAuth2 統合を実装" → "oauth2-api-integration"
     - "分析用のダッシュボードを作成" → "analytics-dashboard"
     - "決済処理のタイムアウトバグを修正" → "fix-payment-timeout"

2. **新しいブランチを作成する前に既存のブランチをチェック**:

   a. まず、すべてのリモートブランチをフェッチして最新情報を取得:
      ```bash
      git fetch --all --prune
      ```

   b. short-name に対する3つのソースすべてから最も高い機能番号を見つける:
      - リモートブランチ: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - ローカルブランチ: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - specs ディレクトリ: `specs/[0-9]+-<short-name>` にマッチするディレクトリをチェック

   c. 次に利用可能な番号を決定:
      - 3つのソースすべてから番号を抽出
      - 最も高い番号 N を見つける
      - 新しいブランチ番号には N+1 を使用

   d. 計算された番号と short-name で `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"` スクリプトを実行:
      - 機能説明と共に `--number N+1` と `--short-name "your-short-name"` を渡す
      - Bash 例: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 例: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要**:
   - 3つのソースすべて（リモートブランチ、ローカルブランチ、specs ディレクトリ）をチェックして最も高い番号を見つける
   - 完全一致する short-name パターンのブランチ/ディレクトリのみをマッチ
   - この short-name の既存のブランチ/ディレクトリが見つからない場合、番号 1 から開始
   - 機能ごとにこのスクリプトを1回だけ実行する必要があります
   - JSON はターミナルに出力として提供されます - 常にそれを参照して、探している実際の内容を取得してください
   - JSON 出力には BRANCH_NAME と SPEC_FILE パスが含まれます
   - "I'm Groot" のような引数の一重引用符には、エスケープ構文を使用: 例 'I'\''m Groot'（または可能であれば二重引用符: "I'm Groot"）

3. `.specify/templates/spec-template.md` を読み込んで、必要なセクションを理解します。

4. 次の実行フローに従います:

    1. 入力からユーザー説明を解析
       空の場合: エラー "機能説明が提供されていません"
    2. 説明から主要概念を抽出
       識別: アクター、アクション、データ、制約
    3. 不明確な側面について:
       - コンテキストと業界標準に基づいて情報に基づいた推測を行う
       - 以下の場合のみ [要明確化: 具体的な質問] でマーク:
         - 選択が機能のスコープやユーザー体験に大きく影響する
         - 異なる意味を持つ複数の合理的な解釈が存在する
         - 合理的なデフォルトが存在しない
       - **制限: 合計最大3つの [要明確化] マーカー**
       - 影響度で優先順位付け: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術詳細
    4. ユーザーシナリオ & テストセクションを記入
       明確なユーザーフローがない場合: エラー "ユーザーシナリオを決定できません"
    5. 機能要件を生成
       各要件はテスト可能である必要があります
       未指定の詳細には合理的なデフォルトを使用（前提セクションに前提を文書化）
    6. 成功基準を定義
       測定可能で、技術非依存の成果を作成
       定量的メトリクス（時間、パフォーマンス、ボリューム）と定性的測定（ユーザー満足度、タスク完了）の両方を含める
       各基準は実装の詳細なしで検証可能である必要があります
    7. 主要エンティティを特定（データが関与する場合）
    8. 戻り値: 成功（計画の準備ができた仕様）

5. テンプレート構造を使用して SPEC_FILE に仕様を書き込み、セクションの順序と見出しを保持しながら、機能説明（引数）から導出された具体的な詳細でプレースホルダーを置き換えます。

6. **仕様品質検証**: 初期仕様を書いた後、品質基準に対して検証します:

   a. **仕様品質チェックリストを作成**: チェックリストテンプレート構造を使用して、これらの検証項目で `FEATURE_DIR/checklists/requirements.md` にチェックリストファイルを生成:

      ```markdown
      # 仕様品質チェックリスト: [機能名]

      **目的**: 計画に進む前に仕様の完全性と品質を検証
      **作成日**: [DATE]
      **機能**: [spec.md へのリンク]

      ## 内容品質

      - [ ] 実装の詳細なし（言語、フレームワーク、API）
      - [ ] ユーザー価値とビジネスニーズに焦点
      - [ ] 非技術者の利害関係者向けに書かれている
      - [ ] すべての必須セクションが完了

      ## 要件の完全性

      - [ ] [要明確化] マーカーが残っていない
      - [ ] 要件はテスト可能で明確
      - [ ] 成功基準は測定可能
      - [ ] 成功基準は技術非依存（実装の詳細なし）
      - [ ] すべての受け入れシナリオが定義されている
      - [ ] エッジケースが特定されている
      - [ ] スコープが明確に境界付けられている
      - [ ] 依存関係と前提が特定されている

      ## 機能準備状況

      - [ ] すべての機能要件に明確な受け入れ基準がある
      - [ ] ユーザーシナリオが主要フローをカバー
      - [ ] 機能が成功基準で定義された測定可能な成果を満たす
      - [ ] 実装の詳細が仕様に漏れていない

      ## 注意事項

      - 不完全とマークされた項目は、`/speckit.clarify` または `/speckit.plan` の前に仕様の更新が必要
      ```

   b. **検証チェックを実行**: 各チェックリスト項目に対して仕様をレビュー:
      - 各項目について、合格または不合格を判定
      - 見つかった具体的な問題を文書化（関連する仕様セクションを引用）

   c. **検証結果を処理**:

      - **すべての項目が合格の場合**: チェックリストを完了としてマークし、ステップ 6 に進む

      - **項目が不合格の場合（[要明確化] を除く）**:
        1. 不合格の項目と具体的な問題をリスト
        2. 各問題に対処するために仕様を更新
        3. すべての項目が合格するまで検証を再実行（最大3回の反復）
        4. 3回の反復後も不合格の場合、チェックリストの注意事項に残りの問題を文書化し、ユーザーに警告

      - **[要明確化] マーカーが残っている場合**:
        1. 仕様からすべての [要明確化: ...] マーカーを抽出
        2. **制限チェック**: 3つ以上のマーカーが存在する場合、最も重要な3つのみを保持（スコープ/セキュリティ/UX の影響度による）し、残りは情報に基づいた推測を行う
        3. 必要な各明確化（最大3つ）について、この形式でユーザーにオプションを提示:

           ```markdown
           ## 質問 [N]: [トピック]

           **コンテキスト**: [関連する仕様セクションを引用]

           **知る必要があること**: [要明確化マーカーからの具体的な質問]

           **推奨される回答**:

           | オプション | 回答 | 影響 |
           |--------|--------|--------------|
           | A      | [最初の推奨回答] | [これが機能にとって何を意味するか] |
           | B      | [2番目の推奨回答] | [これが機能にとって何を意味するか] |
           | C      | [3番目の推奨回答] | [これが機能にとって何を意味するか] |
           | カスタム | 独自の回答を提供 | [カスタム入力の提供方法を説明] |

           **選択**: _[ユーザーの回答を待つ]_
           ```

        4. **重要 - テーブルフォーマット**: マークダウンテーブルが適切にフォーマットされていることを確認:
           - パイプを揃えた一貫したスペーシングを使用
           - 各セルはコンテンツの周りにスペースを持つ必要があります: `| コンテンツ |` であり `|コンテンツ|` ではない
           - ヘッダーセパレーターには少なくとも3つのダッシュが必要: `|--------|`
           - テーブルがマークダウンプレビューで正しくレンダリングされることをテスト
        5. 質問を順番に番号付け（Q1, Q2, Q3 - 合計最大3つ）
        6. 回答を待つ前にすべての質問を一緒に提示
        7. ユーザーがすべての質問に対して選択で回答するのを待つ（例: "Q1: A, Q2: カスタム - [詳細], Q3: B"）
        8. 各 [要明確化] マーカーをユーザーの選択または提供された回答で置き換えて仕様を更新
        9. すべての明確化が解決された後、検証を再実行

   d. **チェックリストを更新**: 各検証反復後、現在の合格/不合格ステータスでチェックリストファイルを更新

7. ブランチ名、仕様ファイルパス、チェックリスト結果、および次のフェーズ（`/speckit.clarify` または `/speckit.plan`）への準備状況を報告して完了を通知。

**注意:** スクリプトは書き込み前に新しいブランチを作成してチェックアウトし、仕様ファイルを初期化します。

## 一般ガイドライン

## クイックガイドライン

- ユーザーが**何を**必要とし、**なぜ**必要なのかに焦点を当てます。
- どのように実装するかを避ける（技術スタック、API、コード構造なし）。
- 開発者ではなく、ビジネス利害関係者向けに書かれています。
- 仕様に埋め込まれたチェックリストは作成しないでください。それは別のコマンドになります。

### セクション要件

- **必須セクション**: すべての機能について完了する必要があります
- **オプションセクション**: 機能に関連する場合のみ含めます
- セクションが適用されない場合は、完全に削除します（"N/A" のままにしないでください）

### AI 生成用

ユーザープロンプトからこの仕様を作成する場合:

1. **情報に基づいた推測を行う**: コンテキスト、業界標準、および一般的なパターンを使用してギャップを埋める
2. **前提を文書化**: 前提セクションに合理的なデフォルトを記録
3. **明確化を制限**: 最大3つの [要明確化] マーカー - 以下の重要な決定にのみ使用:
   - 機能のスコープやユーザー体験に大きく影響する
   - 異なる意味を持つ複数の合理的な解釈がある
   - 合理的なデフォルトがない
4. **明確化の優先順位付け**: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術詳細
5. **テスターのように考える**: すべての曖昧な要件は、"テスト可能で明確" チェックリスト項目に不合格になるべきです
6. **明確化が必要な一般的な領域**（合理的なデフォルトが存在しない場合のみ）:
   - 機能のスコープと境界（特定のユースケースを含める/除外する）
   - ユーザータイプと権限（複数の矛盾する解釈が可能な場合）
   - セキュリティ/コンプライアンス要件（法的/財務的に重要な場合）

**合理的なデフォルトの例**（これらについて尋ねないでください）:

- データ保持: ドメインの業界標準プラクティス
- パフォーマンス目標: 指定がない限り、標準的な web/モバイルアプリの期待
- エラー処理: 適切なフォールバックを持つユーザーフレンドリーなメッセージ
- 認証方法: Web アプリの場合、標準的なセッションベースまたは OAuth2
- 統合パターン: 特に指定がない限り RESTful API

### 成功基準ガイドライン

成功基準は以下である必要があります:

1. **測定可能**: 具体的なメトリクスを含める（時間、パーセンテージ、カウント、レート）
2. **技術非依存**: フレームワーク、言語、データベース、またはツールの言及なし
3. **ユーザー中心**: システム内部ではなく、ユーザー/ビジネスの観点から成果を説明
4. **検証可能**: 実装の詳細を知らなくてもテスト/検証できる

**良い例**:

- "ユーザーは3分以内にチェックアウトを完了できる"
- "システムは性能低下なしに10,000人の同時ユーザーをサポート"
- "95%の検索が1秒以内に結果を返す"
- "タスク完了率が40%向上"

**悪い例**（実装重視）:

- "API 応答時間が200ms未満"（技術的すぎる、"ユーザーは即座に結果を見る" を使用）
- "データベースが1000 TPS を処理できる"（実装の詳細、ユーザー向けのメトリクスを使用）
- "React コンポーネントが効率的にレンダリング"（フレームワーク固有）
- "Redis キャッシュヒット率が80%以上"（技術固有）
