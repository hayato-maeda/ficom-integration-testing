---
description: 利用可能なデザインアーティファクトに基づいて、機能のための実行可能で依存関係順に並べられた tasks.md を生成します。
---

## ユーザー入力

```text
$ARGUMENTS
```

続行する前に、ユーザー入力を**必ず**考慮してください（空でない場合）。

## 概要

1. **セットアップ**: リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json` を実行し、FEATURE_DIR と AVAILABLE_DOCS リストを解析します。すべてのパスは絶対パスである必要があります。"I'm Groot" のような引数の一重引用符には、エスケープ構文を使用: 例 'I'\''m Groot'（または可能であれば二重引用符: "I'm Groot"）。

2. **デザインドキュメントを読み込む**: FEATURE_DIR から読み込み:
   - **必須**: plan.md（技術スタック、ライブラリ、構造）、spec.md（優先度付きユーザーストーリー）
   - **オプション**: data-model.md（エンティティ）、contracts/（API エンドポイント）、research.md（決定事項）、quickstart.md（テストシナリオ）
   - 注意: すべてのプロジェクトがすべてのドキュメントを持っているわけではありません。利用可能なものに基づいてタスクを生成します。

3. **タスク生成ワークフローを実行**:
   - plan.md を読み込み、技術スタック、ライブラリ、プロジェクト構造を抽出
   - spec.md を読み込み、優先度（P1、P2、P3 など）付きユーザーストーリーを抽出
   - data-model.md が存在する場合: エンティティを抽出し、ユーザーストーリーにマッピング
   - contracts/ が存在する場合: エンドポイントをユーザーストーリーにマッピング
   - research.md が存在する場合: セットアップタスクのための決定事項を抽出
   - ユーザーストーリーごとに組織化されたタスクを生成（以下のタスク生成ルールを参照）
   - ユーザーストーリー完了順序を示す依存関係グラフを生成
   - ユーザーストーリーごとの並列実行例を作成
   - タスクの完全性を検証（各ユーザーストーリーに必要なすべてのタスクがあり、独立してテスト可能）

4. **tasks.md を生成**: `.specify.templates/tasks-template.md` を構造として使用し、次の内容で記入:
   - plan.md からの正しい機能名
   - Phase 1: セットアップタスク（プロジェクト初期化）
   - Phase 2: 基盤タスク（すべてのユーザーストーリーのブロッキング前提条件）
   - Phase 3+: ユーザーストーリーごとに1つのフェーズ（spec.md からの優先度順）
   - 各フェーズには: ストーリーの目標、独立テスト基準、テスト（要求された場合）、実装タスク
   - 最終フェーズ: 仕上げ & 横断的関心事
   - すべてのタスクは厳格なチェックリスト形式に従う必要があります（以下のタスク生成ルールを参照）
   - 各タスクの明確なファイルパス
   - ストーリー完了順序を示す依存関係セクション
   - ストーリーごとの並列実行例
   - 実装戦略セクション（MVP 優先、インクリメンタルデリバリー）

5. **報告**: 生成された tasks.md へのパスと要約を出力:
   - 合計タスク数
   - ユーザーストーリーごとのタスク数
   - 特定された並列実行の機会
   - 各ストーリーの独立テスト基準
   - 推奨される MVP スコープ（通常はユーザーストーリー 1 のみ）
   - 形式検証: すべてのタスクがチェックリスト形式に従うことを確認（チェックボックス、ID、ラベル、ファイルパス）

タスク生成のコンテキスト: $ARGUMENTS

tasks.md はすぐに実行可能である必要があります - 各タスクは、LLM が追加のコンテキストなしで完了できるほど具体的である必要があります。

## タスク生成ルール

**重要**: タスクは、独立した実装とテストを可能にするためにユーザーストーリーごとに組織化する必要があります。

**テストは任意**: 機能仕様で明示的に要求された場合、またはユーザーが TDD アプローチを要求した場合にのみ、テストタスクを生成します。

### チェックリスト形式（必須）

すべてのタスクは、この形式に厳密に従う必要があります:

```text
- [ ] [TaskID] [P?] [Story?] ファイルパス付き説明
```

**形式コンポーネント**:

1. **チェックボックス**: 常に `- [ ]`（マークダウンチェックボックス）で開始
2. **タスク ID**: 実行順序の連番（T001、T002、T003...）
3. **[P] マーカー**: タスクが並列化可能な場合のみ含める（異なるファイル、未完了タスクへの依存なし）
4. **[ストーリー] ラベル**: ユーザーストーリーフェーズタスクにのみ必須
   - 形式: [US1]、[US2]、[US3] など（spec.md のユーザーストーリーにマッピング）
   - セットアップフェーズ: ストーリーラベルなし
   - 基盤フェーズ: ストーリーラベルなし
   - ユーザーストーリーフェーズ: ストーリーラベル必須
   - 仕上げフェーズ: ストーリーラベルなし
5. **説明**: 正確なファイルパスを含む明確なアクション

**例**:

- ✅ 正しい: `- [ ] T001 実装計画に従ってプロジェクト構造を作成`
- ✅ 正しい: `- [ ] T005 [P] src/middleware/auth.py に認証ミドルウェアを実装`
- ✅ 正しい: `- [ ] T012 [P] [US1] src/models/user.py に User モデルを作成`
- ✅ 正しい: `- [ ] T014 [US1] src/services/user_service.py に UserService を実装`
- ❌ 間違い: `- [ ] User モデルを作成`（ID とストーリーラベルが欠落）
- ❌ 間違い: `T001 [US1] モデルを作成`（チェックボックスが欠落）
- ❌ 間違い: `- [ ] [US1] User モデルを作成`（タスク ID が欠落）
- ❌ 間違い: `- [ ] T001 [US1] モデルを作成`（ファイルパスが欠落）

### タスクの組織化

1. **ユーザーストーリーから（spec.md）** - 主要な組織化:
   - 各ユーザーストーリー（P1、P2、P3...）は独自のフェーズを取得
   - すべての関連コンポーネントをそのストーリーにマッピング:
     - そのストーリーに必要なモデル
     - そのストーリーに必要なサービス
     - そのストーリーに必要なエンドポイント/UI
     - テストが要求された場合: そのストーリー固有のテスト
   - ストーリーの依存関係をマーク（ほとんどのストーリーは独立している必要があります）

2. **コントラクトから**:
   - 各コントラクト/エンドポイント → それが提供するユーザーストーリーに
   - テストが要求された場合: 各コントラクト → そのストーリーのフェーズ内の実装前のコントラクトテストタスク [P]

3. **データモデルから**:
   - 各エンティティをそれを必要とするユーザーストーリーにマッピング
   - エンティティが複数のストーリーに提供される場合: 最も早いストーリーまたはセットアップフェーズに配置
   - 関係 → 適切なストーリーフェーズのサービス層タスク

4. **セットアップ/インフラストラクチャから**:
   - 共有インフラストラクチャ → セットアップフェーズ（Phase 1）
   - 基盤/ブロッキングタスク → 基盤フェーズ（Phase 2）
   - ストーリー固有のセットアップ → そのストーリーのフェーズ内

### フェーズ構造

- **Phase 1**: セットアップ（プロジェクト初期化）
- **Phase 2**: 基盤（ブロッキング前提条件 - ユーザーストーリーの前に完了する必要があります）
- **Phase 3+**: 優先度順のユーザーストーリー（P1、P2、P3...）
  - 各ストーリー内: テスト（要求された場合）→ モデル → サービス → エンドポイント → 統合
  - 各フェーズは完全で、独立してテスト可能なインクリメントである必要があります
- **最終フェーズ**: 仕上げ & 横断的関心事
