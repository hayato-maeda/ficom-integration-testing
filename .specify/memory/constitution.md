<!--
同期影響レポート
===================
バージョン変更: 1.0.0 → 1.0.1
変更された原則: なし
追加セクション: なし
削除セクション: なし
変更内容: 日本語版への翻訳（PATCH バージョンアップ）
テンプレート更新要件:
  ✅ plan-template.md - Constitution Check セクションが原則と整合
  ✅ spec-template.md - 要件セクションが憲章と互換
  ✅ tasks-template.md - タスク構造が原則駆動開発をサポート
フォローアップ TODO: なし
===================
-->

# Internal DX 憲章

## 基本原則

### I. コード品質（絶対遵守）

すべてのコードは以下の品質基準に準拠しなければなりません：

- **静的解析**: コードは設定されたリンターと型チェッカーを警告なしで通過しなければならない
- **フォーマット**: コードはプロジェクト標準ツール（例: Black, Prettier）を使用して自動フォーマットされなければならない
- **複雑度**: 関数/メソッドは McCabe 複雑度 10 を超えてはならない。違反には明示的な正当化が必要
- **ドキュメント**: 公開 API には目的、パラメータ、戻り値、例外を説明する docstring/コメントが必須
- **デッドコードの禁止**: 未使用のインポート、変数、関数はコミット前に削除しなければならない
- **依存関係管理**: すべての依存関係は特定のバージョンに固定しなければならない。セキュリティ脆弱性は発見から 7 日以内に対処しなければならない

**根拠**: 一貫したコード品質は認知負荷を減らし、バグを防ぎ、長期的な保守性を保証します。自動化された強制により主観的な議論を排除し、より迅速なコードレビューを可能にします。

### II. テストファースト開発（絶対遵守）

テスト駆動開発（TDD）はすべての機能開発において必須です：

- **Red-Green-Refactor**: テストを最初に記述し、失敗することを確認してから実装してパスさせる
- **テストカバレッジ**: 最低 80% のライン・カバレッジが必要。クリティカルパスは 100% カバレッジが必須
- **必須のテストタイプ**:
  - **ユニットテスト**: すべてのビジネスロジック、データ変換、ユーティリティ
  - **統合テスト**: コンポーネント間相互作用、データベース操作、外部サービス呼び出し
  - **契約テスト**: すべての公開 API、CLI インターフェース、サービス間境界
- **テストの独立性**: テストは共有状態や実行順序依存なしで独立して実行できなければならない
- **テストパフォーマンス**: ユニットテストスイートは 60 秒以内、統合テストは 5 分以内に完了しなければならない
- **ミューテーションテスト**: クリティカルなビジネスロジックは 80% 以上のミューテーションスコアを達成すべき

**根拠**: TDD は実装前に要件がテスト可能であることを保証し、早期にリグレッションを検出し、生きたドキュメントとして機能します。事前に書かれたテストは機能肥大化と過剰エンジニアリングを防ぎます。

### III. ユーザー体験の一貫性

すべてのユーザー向けインターフェースは一貫した予測可能な体験を提供しなければなりません：

- **CLI 標準**:
  - フラグと引数について POSIX 規約に従う
  - すべてのコマンドに `--help` ドキュメントを提供
  - 一貫した出力形式（構造化 JSON + 人間が読める表形式）を使用
  - 適切な終了コードを返す（0 = 成功、非ゼロ = 特定のエラータイプ）
  - stdin/stdout パイピングによる組み合わせ可能性をサポート
- **エラーメッセージ**:
  - 明確な次のステップを含む実用的なものでなければならない（例: "ファイルが /path に見つかりません。'command init' を実行して作成してください"）
  - プログラマティックな処理のためのエラーコードを含まなければならない
  - コンテキストを保持しなければならない（デバッグモードではスタックトレース、通常モードではユーザーフレンドリーな要約）
- **API の一貫性**:
  - RESTful エンドポイントは標準的な HTTP セマンティクスに従う（GET = 冪等な読み取り、POST = 作成など）
  - 一貫した命名規則（JSON API には snake_case、JavaScript クライアントには camelCase）
  - バージョン管理されたエンドポイント（例: /api/v1/）と非推奨通知
- **アクセシビリティ**:
  - CLI ツールは色/Unicode なしのフォールバックで動作しなければならない
  - Web インターフェースは WCAG 2.1 AA 基準を満たさなければならない

**根拠**: 一貫した UX は学習曲線を減らし、ユーザーエラーを防ぎ、信頼を構築します。ユーザーはインターフェースの動作に驚かされるべきではありません。

### IV. パフォーマンス基準

すべての機能は定量化可能なパフォーマンス要件を満たさなければなりません：

- **応答時間**:
  - CLI コマンドはローカル操作で 200ms 以内に応答しなければならない
  - API エンドポイントは標準クエリで p95 500ms 以内に応答しなければならない
  - バックグラウンドジョブは 5 秒ごとに進捗フィードバックを提供しなければならない
- **リソース制約**:
  - メモリ使用量は通常のワークロードで 500MB を超えてはならない
  - CPU 使用率はターゲットハードウェアで平均 50% 未満でなければならない
  - ディスク I/O は最小化しなければならない（バッチ書き込み、キャッシング使用）
- **スケーラビリティ**:
  - システムはアーキテクチャ変更なしで現在の負荷の 10 倍を処理できなければならない
  - データベースクエリはインデックスを使用しなければならない。フルテーブルスキャンには正当化が必要
  - 並行操作は安全でなければならない（適切なロック、冪等性）
- **測定**:
  - クリティカルパスにはパフォーマンスベンチマークを含めなければならない
  - リグレッションテストはパフォーマンスが 20% 以上劣化した場合に失敗しなければならない
  - 最適化の機会のためにプロファイリングデータを収集すべき

**根拠**: パフォーマンスは機能であり、後付けではありません。パフォーマンス不足はユーザーの信頼を損ない、スケーラビリティを制限します。定量化可能な基準により客観的な評価が可能になります。

### V. 観測可能性

すべてのシステムはデバッグ可能性と監視のために設計されなければなりません：

- **ログ記録基準**:
  - 構造化ログ（JSON）による機械解析 + 人間が読める形式
  - ログレベル: DEBUG（詳細）、INFO（通常フロー）、WARN（回復可能な問題）、ERROR（対応が必要な失敗）
  - 分散トレーシングのための相関 ID を含める
  - すべての状態変更、外部呼び出し、エラー状態をログに記録
- **メトリクス**:
  - 主要なビジネスメトリクスを追跡（例: リクエスト/秒、エラー率、レイテンシパーセンタイル）
  - ヘルスチェックエンドポイントを公開（`/health`、`/ready`）
  - リソース使用率を記録（CPU、メモリ、ディスク、ネットワーク）
- **デバッグサポート**:
  - 環境変数 `DEBUG=1` で詳細出力を有効化
  - ツールはドライランモードをサポートしなければならない（`--dry-run`、`--what-if`）
  - 設定は検査可能でなければならない（`config show`）
- **監査証跡**:
  - すべての破壊的操作はユーザー/タイムスタンプとともにログに記録しなければならない
  - 状態変更は可逆的であるか、文書化された回復手順を持たなければならない

**根拠**: 観測可能性により迅速なインシデント対応と根本原因分析が可能になります。適切なログとメトリクスがなければ、本番環境の問題のデバッグは推測作業になります。

## 品質ゲート

すべての機能はマージ前に以下のゲートを通過しなければなりません：

1. **コードレビュー**: チームメンバーからの少なくとも 1 つの承認レビュー
2. **自動チェック**:
   - すべてのテストがパス（ユニット、統合、契約）
   - リンティングと型チェックが警告なしでパス
   - テストカバレッジが最小閾値を満たす
   - セキュリティスキャン（依存関係の脆弱性、SAST）
   - パフォーマンスベンチマークが許容範囲内
3. **ドキュメント**:
   - ユーザー向け機能が適切な場所に文書化（CLI ヘルプ、API ドキュメント、ユーザーガイド）
   - 重要な設計選択のためのアーキテクチャ決定記録（ADR）を作成
   - ユーザーに見える変更で変更履歴を更新
4. **憲章準拠**:
   - すべての原則が検証済み（plan.md の Constitution Check を使用）
   - 複雑度違反が Complexity Tracking テーブルで正当化済み

## 開発ワークフロー

### 機能開発プロセス

1. **仕様作成**: `/speckit.specify` を使用してユーザーストーリーと受入基準を含む詳細な機能仕様を作成
2. **計画**: `/speckit.plan` を使用して技術調査と設計を実行
3. **明確化**: `/speckit.clarify` を使用して実装前に不十分な要件を解決
4. **タスク分解**: `/speckit.tasks` を使用して依存関係順、独立テスト可能なタスクを生成
5. **実装**: 優先順位順（P1 → P2 → P3）にタスクを実行し、各タスクを完了としてマーク
6. **検証**: `/speckit.analyze` を実行して成果物間の一貫性を検証
7. **レビュー**: `/speckit.checklist` から生成されたチェックリストを使って PR を提出

### コードレビュー要件

レビュアーは以下を検証しなければなりません：

- テストが最初に書かれ、適切に失敗すること
- コードがすべての憲章原則に準拠していること
- パフォーマンスへの影響が許容範囲内であること
- エラーハンドリングが包括的であること
- ドキュメントが完全かつ正確であること
- テストスイートにリグレッションがないこと

## ガバナンス

### 改訂プロセス

1. **提案**: 根拠を記載した変更提案の issue を作成
2. **議論**: チームが既存機能とワークフローへの影響をレビュー
3. **承認**: コンセンサスが必要（またはチームが指定する場合は多数決）
4. **移行**: すべての依存テンプレート、ドキュメント、既存コードを更新
5. **バージョンアップ**: 憲章バージョンを適切にインクリメント

### バージョニングポリシー

- **MAJOR (x.0.0)**: 後方互換性のないガバナンス変更（例: 原則の削除、必須基準の変更）
- **MINOR (0.x.0)**: 新しい原則の追加、既存セクションの重要な拡張
- **PATCH (0.0.x)**: 明確化、文言改善、誤字修正

### 準拠レビュー

- **マージ前**: 自動チェックがリンティング、テスト、カバレッジ基準を強制
- **月次監査**: 自動化できない原則（UX 一貫性、観測可能性、ドキュメント品質）への準拠について最近の PR をレビュー
- **四半期振り返り**: 憲章の有効性を評価し、改訂を提案

### 複雑度の正当化

複雑度ガイドライン違反時（例: 関数複雑度 >10、追加の抽象化レイヤー）、plan.md の Complexity Tracking テーブルに文書化：

| 違反 | 必要な理由 | より単純な代替案を却下した理由 |
|------|-----------|----------------------------|
| 例エントリ | 具体的な技術的制約 | 具体的なトレードオフの説明 |

**バージョン**: 1.0.1 | **制定日**: 2025-10-20 | **最終改訂日**: 2025-10-20
